<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on Aiur · Zellux 的博客</title>
    <link>https://blog.yxwang.me/tags/notes/</link>
    <description>Recent content in Notes on Aiur · Zellux 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 07 Aug 2018 00:56:13 -0700</lastBuildDate>
    
	<atom:link href="https://blog.yxwang.me/tags/notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SLAM 笔记 4：定位</title>
      <link>https://blog.yxwang.me/2018/08/robotics-slam-week4/</link>
      <pubDate>Tue, 07 Aug 2018 00:56:13 -0700</pubDate>
      
      <guid>https://blog.yxwang.me/2018/08/robotics-slam-week4/</guid>
      <description>&lt;p&gt;最后一周讲定位 (localization)，也就是 SLAM 里面的 L。主要包括粒子滤波和迭代最近点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SLAM 笔记 3：地图</title>
      <link>https://blog.yxwang.me/2018/08/robotics-slam-week3/</link>
      <pubDate>Wed, 01 Aug 2018 00:07:22 -0700</pubDate>
      
      <guid>https://blog.yxwang.me/2018/08/robotics-slam-week3/</guid>
      <description>&lt;p&gt;这一周的内容和地图有关，最后的作业就是通过传感器的数据创建一个地图。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SLAM 笔记 2：卡尔曼滤波</title>
      <link>https://blog.yxwang.me/2018/07/robotics-slam-week2/</link>
      <pubDate>Wed, 25 Jul 2018 07:57:26 +0000</pubDate>
      
      <guid>https://blog.yxwang.me/2018/07/robotics-slam-week2/</guid>
      <description>&lt;p&gt;这一周主要讲卡尔曼滤波 (Kalman Filter)，视频讲得比较简略，slides 做得里也有不少错误。最后看了一些其他网站的文章和视频才有了比较深刻的理解。参考资料推荐在本文结尾。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SLAM 笔记 1：高斯分布</title>
      <link>https://blog.yxwang.me/2018/07/robotics-slam-week1/</link>
      <pubDate>Mon, 23 Jul 2018 00:18:32 +0000</pubDate>
      
      <guid>https://blog.yxwang.me/2018/07/robotics-slam-week1/</guid>
      <description>&lt;p&gt;最近宾大在 Coursera 上开了一个&lt;a href=&#34;https://www.coursera.org/specializations/robotics&#34;&gt;机器人系列课程&lt;/a&gt;，包含了视觉、运动规划、机械设计等课题。我对 &lt;a href=&#34;https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping&#34;&gt;SLAM&lt;/a&gt; 很感兴趣，于是就选了 Robotics Estimation and Learning 这门课，课程主页是&lt;a href=&#34;https://www.coursera.org/learn/robotics-learning/&#34; class=&#34;uri&#34;&gt;https://www.coursera.org/learn/robotics-learning/&lt;/a&gt;。第一周的内容是高斯分布。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>线性代数笔记</title>
      <link>https://blog.yxwang.me/2018/07/linear-algebra-notes/</link>
      <pubDate>Sat, 14 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yxwang.me/2018/07/linear-algebra-notes/</guid>
      <description>最近抽空把线性代数重新过了一遍，整理了一份概念笔记，希望对别人也有用。主要参考了同济大学的《线性代数》和 《Deep Learning》 的第二章。
行列式  行列式 (determinant) 与它的转置行列式相等。\(D^T = D\) 余子式 (minor)：在 n 阶行列式中，把 \((i, j)\) 元 \(a_{ij}\) 所在的第 \(i\) 行和第 \(j\) 列划去后留下的 \(n - 1\) 阶行列式叫做 \((i, j)\) 元 \(a_{ij}\) 的余子式，记作 \(M_{ij}\) 代数余子式 (cofactor) \(A_{ij} = (-1)^{i+j}M_{ij}\) 行列式按行展开：\(D = a_{i1}A_{i1} + a_{i2}A_{i2} + \cdots + a_{in}A_{in}\) 行列式按列展开：\(D = a_{1j}A_{1j} + a_{2j}A_{2j} + \cdots + a_{nj}A_{nj}\) 克拉默法则 (Cramer’s rule)：如果线性方程组的系数行列式不等于零，那么方程组有唯一解 \(x_1 = \frac{D_1}{D}, x_2 = \frac{D_2}{D}, \cdots, x_n = \frac{D_n}{D}\)， 其中 \(D_j\) 是把系数行列式 D 中第 j 列的元素用方程组右端的常数项代替后得到的 n 阶行列式。  矩阵及其运算  伴随矩阵 (adjugate matrix) \[ adj(A) = \begin{bmatrix} A_{11} &amp;amp; A_{21} &amp;amp; \cdots &amp;amp; A_{n1} \\ A_{12} &amp;amp; A_{22} &amp;amp; \cdots &amp;amp; A_{n2} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ A_{1n} &amp;amp; A_{2n} &amp;amp; \cdots &amp;amp; A_{nn} \\ \end{bmatrix} \]  其中 \(A_{ij}\) 为代数余子式</description>
    </item>
    
    <item>
      <title>Xen 学习笔记 2009-02-10</title>
      <link>https://blog.yxwang.me/2009/02/2009-02-10-notes/</link>
      <pubDate>Wed, 11 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yxwang.me/2009/02/2009-02-10-notes/</guid>
      <description>x86_64上不支持segment机制，Xen是通过页表机制来控制访问权限的，Xen及其相关数据驻留在0xffff8000 00000000 - 0xffff87ff ffffffff，也就是在原来的kernel space的低地址部分，而x86_32上驻留在最上面的。  [include/asm-x86/config.h] /* * Memory layout: * 0x0000000000000000 - 0x00007fffffffffff [128TB, 2^47 bytes, PML4:0-255] * Guest-defined use (see below for compatibility mode guests). * 0x0000800000000000 - 0xffff7fffffffffff [16EB] * Inaccessible: current arch only supports 48-bit sign-extended VAs. * 0xffff800000000000 - 0xffff803fffffffff [256GB, 2^38 bytes, PML4:256] * Read-only machine-to-phys translation table (GUEST ACCESSIBLE). * 0xffff804000000000 - 0xffff807fffffffff [256GB, 2^38 bytes, PML4:256] * Reserved for future shared info with the guest OS (GUEST ACCESSIBLE).</description>
    </item>
    
    <item>
      <title>OS Lab 5 Debugging Notes</title>
      <link>https://blog.yxwang.me/2008/08/os-lab5-debug-notes/</link>
      <pubDate>Sun, 31 Aug 2008 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yxwang.me/2008/08/os-lab5-debug-notes/</guid>
      <description>还算顺利，不过这个lab蛮无聊的，等有空了把syscall改成类似linux的做法，单一中断号+寄存器选择syscall。
 最花时间的一个bug是ls返回值没有改成应用程序数，结果一开始一直以为是brk系统调用没写好，最后才发现问题出在这么小的地方。
 brk的逻辑还不是很清楚，尽管通过了简单的测试，但是debug输出的信息显示brk增长的很快，经常是一个页一个页涨的，看来还得查下brk的具体行为。
 写了个比MAGIC_BREAK好用一点的宏，因为用户态的程序都是按二进制读入的，Simics无法得到函数信息（函数名、当前行数等），利用C99的宏写了个新的INFO_BREAK
  #define INFO_BREAK \ do { \ lprintf_kern(&amp;quot;break in %s:%d&amp;quot;, __FUNCTION__, __LINE__); \ MAGIC_BREAK; \ } while (0) \  </description>
    </item>
    
    <item>
      <title>OS Lab 4 Debugging Notes</title>
      <link>https://blog.yxwang.me/2008/08/bugs-related-to-my-fork/</link>
      <pubDate>Fri, 22 Aug 2008 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yxwang.me/2008/08/bugs-related-to-my-fork/</guid>
      <description> 系统调用 fork() 用Simics跟踪一条条汇编分析页表映射、寄存器值还真是体力活啊。。
 实现 Copy On Write 时，如果某一个用户态页面有多个进程共享，其中一个进程修改该页面时需要创建一个新的页面。一开始偶忘了把原来页面的内容复制到新的页面了 =_= 另外由于新的页面要代替老的页面，或者说它们的物理地址不同，但虚拟地址相同，我的方法是在内核态开辟一个大小为一个页面的空间作为中转。
 do_fork函数中，子进程复制父进程的页表的同时会把父进程页表项置为不可写，注意最后要flush tlb。因为一开始没有flush tlb，导致最后用户态fork返回以后读取的信息来自于tlb，直接改写了共享页面中fork的返回地址，导致切换到子进程时fork的返回地址丢失。这个bug让我郁闷了两三个小时。。
 使用两次fork时，第二次fork返回的pid会被改掉。查了下发现为用户空间分配物理页面的代码里居然在分配好以后没有把对应的struct置为已使用，结果导致第二个子进程COW创建新页面时得到了原来的父进程页面，改写了父进程页面内容。
  系统调用 exec()  清空页表的用户空间映射的函数一开始写得yts，bug到处都是，比如free的时候没使用指向内存块首地址的指针，记录内存地址的变量没有累加。 exec传递给内核态的两个参数必须先在内核态保存一个副本，否则清空用户态页表后就无法得到这两个参数信息了。 分配给用户态的页面必须先清零，一方面考虑到安全性，另一方面不清零会隐藏一些潜在的bug。一开始我没有在内核执行exec的时候完整的复制所有的参数，而是直接指向了原进程的内存空间，由于清空页表后再次申请新页表时得到了原来的页面，结果正好原来那个保存参数的页面和新进程的该页面重合了 =_= 于是浪费了不少时间在这个bug上  </description>
    </item>
    
  </channel>
</rss>